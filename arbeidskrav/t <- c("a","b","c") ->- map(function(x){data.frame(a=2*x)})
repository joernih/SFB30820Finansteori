map                   package:purrr                    R Documentation

_A_p_p_l_y _a _f_u_n_c_t_i_o_n _t_o _e_a_c_h _e_l_e_m_e_n_t _o_f _a _l_i_s_t _o_r _a_t_o_m_i_c _v_e_c_t_o_r

_D_e_s_c_r_i_p_t_i_o_n:

     The map functions transform their input by applying a function to
     each element of a list or atomic vector and returning an object of
     the same length as the input.

        • ‘map()’ always returns a list. See the ‘modify()’ family for
          versions that return an object of the same type as the input.

        • ‘map_lgl()’, ‘map_int()’, ‘map_dbl()’ and ‘map_chr()’ return
          an atomic vector of the indicated type (or die trying).

        • ‘map_dfr()’ and ‘map_dfc()’ return a data frame created by
          row-binding and column-binding respectively. They require
          dplyr to be installed.

        • The returned values of ‘.f’ must be of length one for each
          element of ‘.x’. If ‘.f’ uses an extractor function shortcut,
          ‘.default’ can be specified to handle values that are absent
          or empty. See ‘as_mapper()’ for more on ‘.default’.

        • ‘walk()’ calls ‘.f’ for its side-effect and returns the input
          ‘.x’.

_U_s_a_g_e:

     map(.x, .f, ...)
     
     map_lgl(.x, .f, ...)
     
     map_chr(.x, .f, ...)
     
     map_int(.x, .f, ...)
     
     map_dbl(.x, .f, ...)
     
     map_raw(.x, .f, ...)
     
     map_dfr(.x, .f, ..., .id = NULL)
     
     map_dfc(.x, .f, ...)
     
     walk(.x, .f, ...)
     
_A_r_g_u_m_e_n_t_s:

      .x: A list or atomic vector.

      .f: A function, formula, or vector (not necessarily atomic).

          If a *function*, it is used as is.

          If a *formula*, e.g. ‘~ .x + 2’, it is converted to a
          function. There are three ways to refer to the arguments:

            • For a single argument function, use ‘.’

            • For a two argument function, use ‘.x’ and ‘.y’

            • For more arguments, use ‘..1’, ‘..2’, ‘..3’ etc

          This syntax allows you to create very compact anonymous
          functions.

          If *character vector*, *numeric vector*, or *list*, it is
          converted to an extractor function. Character vectors index
          by name and numeric vectors index by position; use a list to
          index by position and name at different levels. If a
          component is not present, the value of ‘.default’ will be
          returned.

     ...: Additional arguments passed on to the mapped function.

     .id: Either a string or ‘NULL’. If a string, the output will
          contain a variable with that name, storing either the name
          (if ‘.x’ is named) or the index (if ‘.x’ is unnamed) of the
          input. If ‘NULL’, the default, no variable will be created.

          Only applies to _dfr variant.

_V_a_l_u_e:

        • ‘map()’ Returns a list the same length as ‘.x’.

        • ‘map_lgl()’ returns a logical vector, ‘map_int()’ an integer
          vector, ‘map_dbl()’ a double vector, and ‘map_chr()’ a
          character vector.

        • ‘map_df()’, ‘map_dfc()’, ‘map_dfr()’ all return a data frame.

        • If ‘.x’ has ‘names()’, the return value preserves those
          names.

        • The output of ‘.f’ will be automatically typed upwards, e.g.
          logical -> integer -> double -> character.

        • ‘walk()’ returns the input ‘.x’ (invisibly). This makes it
          easy to use in pipe.

_S_e_e _A_l_s_o:

     ‘map_if()’ for applying a function to only those elements of ‘.x’
     that meet a specified condition.

     Other map variants: ‘imap()’, ‘invoke()’, ‘lmap()’, ‘map2()’,
     ‘map_if()’, ‘modify()’

_E_x_a_m_p_l_e_s:

     # Compute normal distributions from an atomic vector
     1:10 %>%
       map(rnorm, n = 10)
     
     # You can also use an anonymous function
     1:10 %>%
       map(function(x) rnorm(10, x))
     
     # Or a formula
     1:10 %>%
       map(~ rnorm(10, .x))
     
     # Simplify output to a vector instead of a list by computing the mean of the distributions
     1:10 %>%
       map(rnorm, n = 10) %>%  # output a list
       map_dbl(mean)           # output an atomic vector
     
     # Using set_names() with character vectors is handy to keep track
     # of the original inputs:
     set_names(c("foo", "bar")) %>% map_chr(paste0, ":suffix")
     
     # Working with lists
     favorite_desserts <- list(Sophia = "banana bread", Eliott = "pancakes", Karina = "chocolate cake")
     favorite_desserts %>% map_chr(~ paste(.x, "rocks!"))
     
     # Extract by name or position
     # .default specifies value for elements that are missing or NULL
     l1 <- list(list(a = 1L), list(a = NULL, b = 2L), list(b = 3L))
     l1 %>% map("a", .default = "???")
     l1 %>% map_int("b", .default = NA)
     l1 %>% map_int(2, .default = NA)
     
     # Supply multiple values to index deeply into a list
     l2 <- list(
       list(num = 1:3,     letters[1:3]),
       list(num = 101:103, letters[4:6]),
       list()
     )
     l2 %>% map(c(2, 2))
     
     # Use a list to build an extractor that mixes numeric indices and names,
     # and .default to provide a default value if the element does not exist
     l2 %>% map(list("num", 3))
     l2 %>% map_int(list("num", 3), .default = NA)
     
     # Working with data frames
     # Use map_lgl(), map_dbl(), etc to return a vector instead of a list:
     mtcars %>% map_dbl(sum)
     
     # A more realistic example: split a data frame into pieces, fit a
     # model to each piece, summarise and extract R^2
     mtcars %>%
       split(.$cyl) %>%
       map(~ lm(mpg ~ wt, data = .x)) %>%
       map(summary) %>%
       map_dbl("r.squared")
     
     # If each element of the output is a data frame, use
     # map_dfr to row-bind them together:
     mtcars %>%
       split(.$cyl) %>%
       map(~ lm(mpg ~ wt, data = .x)) %>%
       map_dfr(~ as.data.frame(t(as.matrix(coef(.)))))
     # (if you also want to preserve the variable names see
     # the broom package)
     

